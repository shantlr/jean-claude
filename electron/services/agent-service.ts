// Agent Service — backend-agnostic orchestration layer.
// Manages agent sessions using the AgentBackend interface.
// Handles session lifecycle, message persistence, IPC forwarding,
// prompt queueing, notifications, and session allow tools.

import { BrowserWindow } from 'electron';
import { nanoid } from 'nanoid';

import type {
  AgentBackend,
  AgentBackendType,
  AgentEvent,
  NormalizedPermissionRequest,
  NormalizedQuestion,
  NormalizedQuestionRequest,
} from '@shared/agent-backend-types';
import {
  AGENT_CHANNELS,
  type AgentQuestion,
  type PermissionResponse,
  type QuestionResponse,
  type QueuedPrompt,
} from '@shared/agent-types';
import type { AgentUIEventPayload } from '@shared/agent-ui-events';
import type { NormalizedEntry } from '@shared/normalized-message-v2';
import type { InteractionMode } from '@shared/types';

import {
  TaskRepository,
  ProjectRepository,
  AgentMessageRepository,
  RawMessageRepository,
} from '../database/repositories';
import { dbg } from '../lib/debug';
import { pathExists } from '../lib/fs';

import { AGENT_BACKEND_CLASSES } from './agent-backends';
import { generateTaskName } from './name-generation-service';
import { notificationService } from './notification-service';
import { getEffectivePermissions } from './permission-settings-service';

// --- Active session tracking ---

interface ActiveSession {
  taskId: string;
  backendSessionId: string | null; // The session ID from the backend
  sdkSessionId: string | null; // The persistent session ID for resumption
  backendType: AgentBackendType;
  backend: AgentBackend;
  messageIndex: number;
  queuedPrompts: QueuedPrompt[];
  abortController: AbortController;
  // Track pending requests for getPendingRequest()
  pendingRequests: Array<{
    requestId: string;
    type: 'permission' | 'question';
    permissionRequest?: NormalizedPermissionRequest;
    questionRequest?: NormalizedQuestionRequest;
  }>;
}

class AgentService {
  private sessions: Map<string, ActiveSession> = new Map();
  private mainWindow: BrowserWindow | null = null;

  setMainWindow(window: BrowserWindow) {
    this.mainWindow = window;
  }

  private emitEvent(taskId: string, event: AgentUIEventPayload) {
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      this.mainWindow.webContents.send(AGENT_CHANNELS.EVENT, {
        taskId,
        ...event,
      });
    }
  }

  /**
   * Persist and emit a synthetic normalized entry (not from a backend).
   * Used for user message echo, error messages, and interruption messages
   * generated by agent-service. These have no raw SDK backing, so rawMessageId is null.
   */
  private async persistAndEmitSyntheticEntry(
    taskId: string,
    session: ActiveSession,
    entry: NormalizedEntry,
  ) {
    try {
      await AgentMessageRepository.create({
        taskId,
        messageIndex: session.messageIndex++,
        entry,
        rawMessageId: null,
      });
    } catch (error) {
      dbg.agent('Failed to persist synthetic entry: %O', error);
    }
    this.emitEvent(taskId, { type: 'entry', entry });
  }

  private async generateAndPersistTaskName(
    taskId: string,
    prompt: string,
  ): Promise<void> {
    try {
      const name = await generateTaskName(prompt);
      if (name) {
        await TaskRepository.update(taskId, { name });
        this.emitEvent(taskId, { type: 'name-updated', name });
        dbg.agent('Generated task name for %s: %s', taskId, name);
      }
    } catch (error) {
      dbg.agent('Failed to generate task name for %s: %O', taskId, error);
    }
  }

  // --- Session management ---

  private async createSession(taskId: string): Promise<ActiveSession> {
    const existingMessageCount =
      await AgentMessageRepository.getMessageCount(taskId);
    const task = await TaskRepository.findById(taskId);

    const backendType: AgentBackendType = task!.agentBackend;
    const BackendClass = AGENT_BACKEND_CLASSES[backendType];
    if (!BackendClass) {
      throw new Error(`Unknown agent backend: "${backendType}"`);
    }
    const backend = new BackendClass({
      taskId,
      sessionStartIndex: existingMessageCount,
      persistRaw: async (params) => {
        const row = await RawMessageRepository.create({
          taskId,
          messageIndex: params.messageIndex,
          backendSessionId: params.backendSessionId,
          rawData: params.rawData,
          rawFormat: backendType,
        });
        return row.id;
      },
    });

    const session: ActiveSession = {
      taskId,
      backendSessionId: null,
      sdkSessionId: task?.sessionId ?? null,
      backendType,
      backend,
      messageIndex: existingMessageCount,
      queuedPrompts: [],
      abortController: new AbortController(),
      pendingRequests: [],
    };

    this.sessions.set(taskId, session);
    dbg.agentSession(
      'Created session for task %s (backend: %s, resuming: %s, messageIndex: %d)',
      taskId,
      backendType,
      session.sdkSessionId ? 'yes' : 'no',
      existingMessageCount,
    );
    return session;
  }

  // --- Main event loop ---

  /**
   * Run the agent backend for a task, processing events from the backend's
   * event stream. Handles message persistence, permission/question forwarding,
   * result handling, and queued prompts.
   */
  private async runBackend(
    taskId: string,
    prompt: string,
    session: ActiveSession,
    options?: { generateNameOnInit?: boolean; initialPrompt?: string },
  ): Promise<void> {
    const task = await TaskRepository.findById(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    const project = await ProjectRepository.findById(task.projectId);
    if (!project) {
      throw new Error(`Project ${task.projectId} not found`);
    }

    // Validate worktree exists if this is a worktree task
    if (task.worktreePath && !(await pathExists(task.worktreePath))) {
      throw new Error(
        `The worktree for this task has been deleted. To continue working, ` +
          `create a new task or restore the worktree at: ${task.worktreePath}`,
      );
    }

    const workingDir = task.worktreePath ?? project.path;

    dbg.agentSession(
      'runBackend for task %s: backend=%s, cwd=%s, resuming=%s',
      taskId,
      session.backendType,
      workingDir,
      session.sdkSessionId ? 'yes' : 'no',
    );

    if (task.status !== 'running') {
      await TaskRepository.update(taskId, { status: 'running' });
      this.emitEvent(taskId, { type: 'status', status: 'running' });
    }

    // Create new abort controller for this query iteration
    session.abortController = new AbortController();

    if (options?.generateNameOnInit && task.name === null) {
      // NOTE: fire-and-forget
      void this.generateAndPersistTaskName(
        taskId,
        options.initialPrompt ?? prompt,
      ).catch((err) => {
        dbg.agent('Error generating task name: %O', err);
      });
    }

    // Emit user entry before starting the backend
    await this.persistAndEmitSyntheticEntry(taskId, session, {
      id: nanoid(),
      date: new Date().toISOString(),
      isSynthetic: true,
      type: 'user-prompt',
      value: prompt,
    });

    // Load settings file permissions and merge with task's sessionAllowedTools.
    // This ensures permissions set via "Allow for Project" / "Allow for Worktrees"
    // are available for auto-allow logic (e.g., Bash commands auto-allowed when
    // Read/Write is permitted via settings files).
    const settingsPermissions = await getEffectivePermissions(workingDir);
    const taskAllowedTools = task.sessionAllowedTools ?? [];
    const mergedAllowedTools = [
      ...new Set([...taskAllowedTools, ...settingsPermissions]),
    ];

    // Start the backend
    dbg.agentSession('Starting backend for task %s', taskId);
    const agentSession = await session.backend.start(
      {
        type: session.backendType,
        cwd: workingDir,
        interactionMode: (task.interactionMode ?? 'ask') as InteractionMode,
        model:
          task.modelPreference && task.modelPreference !== 'default'
            ? task.modelPreference
            : undefined,
        sessionId: session.sdkSessionId ?? undefined,
        sessionAllowedTools: mergedAllowedTools,
      },
      prompt,
    );

    session.backendSessionId = agentSession.sessionId;

    // Process the event stream
    for await (const event of agentSession.events) {
      if (session.abortController.signal.aborted) {
        dbg.agentSession('Task %s aborted, breaking event loop', taskId);
        break;
      }

      await this.processEvent(taskId, session, event);
    }
  }

  /**
   * Process a single event from the backend event stream.
   */
  private async processEvent(
    taskId: string,
    session: ActiveSession,
    event: AgentEvent,
  ): Promise<void> {
    switch (event.type) {
      case 'session-id': {
        session.sdkSessionId = event.sessionId;
        // Only persist the first session ID — once set it is immutable.
        const existing = await TaskRepository.findById(taskId);
        if (!existing?.sessionId) {
          await TaskRepository.update(taskId, { sessionId: event.sessionId });
          dbg.agentSession(
            'Captured session ID for task %s: %s',
            taskId,
            event.sessionId,
          );
        } else {
          dbg.agentSession(
            'Session ID already set for task %s (%s), ignoring new value: %s',
            taskId,
            existing.sessionId,
            event.sessionId,
          );
        }
        break;
      }

      case 'entry': {
        try {
          await AgentMessageRepository.create({
            taskId,
            messageIndex: session.messageIndex++,
            entry: event.entry,
            rawMessageId: event.rawMessageId,
          });
        } catch (error) {
          dbg.agent('Failed to persist entry: %O', error);
        }
        this.emitEvent(taskId, { type: 'entry', entry: event.entry });
        break;
      }

      case 'entry-update': {
        try {
          await AgentMessageRepository.updateEntry({
            taskId,
            entry: event.entry,
          });
        } catch (error) {
          dbg.agent('Failed to update entry: %O', error);
        }
        this.emitEvent(taskId, {
          type: 'entry-update',
          entry: event.entry,
        });
        break;
      }

      case 'tool-result': {
        try {
          await AgentMessageRepository.updateToolResult({
            taskId,
            toolId: event.toolId,
            result: event.result,
            isError: event.isError,
            durationMs: event.durationMs,
          });
        } catch (error) {
          dbg.agent('Failed to update tool result: %O', error);
        }
        this.emitEvent(taskId, {
          type: 'tool-result',
          toolId: event.toolId,
          result: event.result,
          isError: event.isError,
          durationMs: event.durationMs,
        });
        break;
      }

      case 'permission-request': {
        const request = event.request;
        // Track the pending request
        session.pendingRequests.push({
          requestId: request.requestId,
          type: 'permission',
          permissionRequest: request,
        });

        await TaskRepository.update(taskId, { status: 'waiting' });
        this.emitEvent(taskId, { type: 'status', status: 'waiting' });
        this.emitEvent(taskId, {
          type: 'permission',
          ...request,
        });

        // Send desktop notification if window not focused
        if (this.mainWindow && !this.mainWindow.isFocused()) {
          const task = await TaskRepository.findById(taskId);
          notificationService.notify(
            'Permission Required',
            `Task "${task?.name || 'Unknown'}" needs approval for ${request.toolName}`,
            () => {
              this.mainWindow?.focus();
            },
          );
        }
        break;
      }

      case 'question': {
        const request = event.request;
        // Track the pending request
        session.pendingRequests.push({
          requestId: request.requestId,
          type: 'question',
          questionRequest: request,
        });

        await TaskRepository.update(taskId, { status: 'waiting' });
        this.emitEvent(taskId, { type: 'status', status: 'waiting' });

        const questions: AgentQuestion[] = request.questions.map(
          (q: NormalizedQuestion) => ({
            question: q.question,
            header: q.header,
            options: q.options.map((o) => ({
              label: o.label,
              description: o.description,
            })),
            multiSelect: q.multiSelect,
          }),
        );
        this.emitEvent(taskId, {
          type: 'question',
          requestId: request.requestId,
          questions,
        });

        // Send desktop notification if window not focused
        if (this.mainWindow && !this.mainWindow.isFocused()) {
          const task = await TaskRepository.findById(taskId);
          notificationService.notify(
            'Question from Agent',
            `Task "${task?.name || 'Unknown'}" has a question`,
            () => {
              this.mainWindow?.focus();
            },
          );
        }
        break;
      }

      case 'complete': {
        const result = event.result;
        dbg.agentSession(
          'Task %s received result (isError: %s, queued: %d)',
          taskId,
          result.isError,
          session.queuedPrompts.length,
        );

        // Sync session-allowed tools back to the task
        if (
          session.backend.getSessionAllowedTools &&
          session.backendSessionId
        ) {
          const tools = session.backend.getSessionAllowedTools(
            session.backendSessionId,
          );
          if (tools.length > 0) {
            const currentTask = await TaskRepository.findById(taskId);
            const existingTools = currentTask?.sessionAllowedTools ?? [];
            const merged = [...new Set([...existingTools, ...tools])];
            if (merged.length !== existingTools.length) {
              await TaskRepository.update(taskId, {
                sessionAllowedTools: merged,
              });
            }
          }
        }

        // Check for queued prompts
        const nextPrompt = session.queuedPrompts.shift();
        if (nextPrompt && !result.isError) {
          dbg.agentSession('Task %s processing next queued prompt', taskId);
          this.emitEvent(taskId, {
            type: 'queue-update',
            queuedPrompts: session.queuedPrompts,
          });
          // Recursively process next queued prompt
          return await this.runBackend(taskId, nextPrompt.content, session);
        }

        // No more queued prompts - finalize
        const status = result.isError ? 'errored' : 'completed';
        await TaskRepository.update(taskId, { status });
        this.emitEvent(taskId, { type: 'status', status });

        // Notify on completion
        if (this.mainWindow && !this.mainWindow.isFocused()) {
          const updatedTask = await TaskRepository.findById(taskId);
          notificationService.notify(
            status === 'completed' ? 'Task Completed' : 'Task Failed',
            `Task "${updatedTask?.name || 'Unknown'}" ${status === 'completed' ? 'finished successfully' : 'encountered an error'}`,
            () => {
              this.mainWindow?.focus();
            },
          );
        }
        break;
      }

      case 'error': {
        dbg.agent('Backend error for task %s: %s', taskId, event.error);

        // Emit a synthetic error entry so the user sees the error in the timeline
        await this.persistAndEmitSyntheticEntry(taskId, session, {
          id: nanoid(),
          date: new Date().toISOString(),
          isSynthetic: true,
          type: 'result',
          value: event.error,
          isError: true,
        });

        await TaskRepository.update(taskId, { status: 'errored' });
        this.emitEvent(taskId, {
          type: 'status',
          status: 'errored',
          error: event.error,
        });
        break;
      }

      case 'mode-change': {
        await TaskRepository.update(taskId, { interactionMode: event.mode });
        break;
      }

      default:
        // Other event types (session-updated, tool-state-update, etc.)
        // are logged but not actively handled yet
        dbg.agent('Unhandled event type for task %s: %s', taskId, event.type);
        break;
    }
  }

  // --- Public API ---

  async start(taskId: string): Promise<void> {
    // Check if already running
    if (this.sessions.has(taskId)) {
      throw new Error(`Agent already running for task ${taskId}`);
    }

    // Get task info for prompt
    const task = await TaskRepository.findById(taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    // Create session
    const session = await this.createSession(taskId);

    // Update task status
    await TaskRepository.update(taskId, { status: 'running' });
    this.emitEvent(taskId, { type: 'status', status: 'running' });

    try {
      dbg.agentSession('Starting agent for task %s', taskId);
      await this.runBackend(taskId, task.prompt, session, {
        generateNameOnInit: true,
        initialPrompt: task.prompt,
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      dbg.agent('Task %s start failed: %s', taskId, errorMessage);

      // Emit a synthetic error entry so the user sees the error in the timeline
      await this.persistAndEmitSyntheticEntry(taskId, session, {
        id: nanoid(),
        date: new Date().toISOString(),
        isSynthetic: true,
        type: 'result',
        value: errorMessage,
        isError: true,
      });

      await TaskRepository.update(taskId, { status: 'errored' });
      this.emitEvent(taskId, {
        type: 'status',
        status: 'errored',
        error: errorMessage,
      });
    } finally {
      this.sessions.delete(taskId);
    }
  }

  async stop(taskId: string): Promise<void> {
    dbg.agentSession('Stopping task %s', taskId);
    const session = this.sessions.get(taskId);
    if (!session) {
      dbg.agentSession('No session found for task %s, nothing to stop', taskId);
      return;
    }

    // Clear queued prompts
    session.queuedPrompts = [];
    this.emitEvent(taskId, { type: 'queue-update', queuedPrompts: [] });

    session.abortController.abort();

    // Stop the backend
    if (session.backendSessionId) {
      await session.backend.stop(session.backendSessionId);
    }

    // Emit a custom interruption entry
    await this.persistAndEmitSyntheticEntry(taskId, session, {
      id: nanoid(),
      date: new Date().toISOString(),
      isSynthetic: true,
      type: 'result',
      value: 'Task interrupted by user',
      isError: true,
    });

    await TaskRepository.update(taskId, { status: 'interrupted' });
    this.emitEvent(taskId, {
      type: 'status',
      status: 'interrupted',
      error: 'Stopped by user',
    });
    this.sessions.delete(taskId);
    dbg.agentSession('Task %s stopped and session cleaned up', taskId);
  }

  async respond(
    taskId: string,
    requestId: string,
    response: PermissionResponse | QuestionResponse,
  ): Promise<void> {
    dbg.agentPermission(
      'Responding to request %s for task %s',
      requestId,
      taskId,
    );
    const session = this.sessions.get(taskId);
    if (!session) {
      throw new Error(`No active session for task ${taskId}`);
    }

    // Find and remove the pending request
    const requestIndex = session.pendingRequests.findIndex(
      (r) => r.requestId === requestId,
    );
    if (requestIndex === -1) {
      throw new Error(`No pending request with ID ${requestId}`);
    }

    const [request] = session.pendingRequests.splice(requestIndex, 1);
    dbg.agentPermission(
      'Resolved %s request (remaining pending: %d)',
      request.type,
      session.pendingRequests.length,
    );

    // Forward to the backend
    if (request.type === 'permission') {
      const permResponse = response as PermissionResponse;
      await session.backend.respondToPermission(
        session.backendSessionId!,
        requestId,
        {
          behavior: permResponse.behavior,
          updatedInput: permResponse.updatedInput,
          message: permResponse.message,
        },
      );
    } else {
      const questionResponse = response as QuestionResponse;
      await session.backend.respondToQuestion(
        session.backendSessionId!,
        requestId,
        questionResponse.answers,
      );
    }

    // Resume running status
    await TaskRepository.update(taskId, { status: 'running' });
    this.emitEvent(taskId, { type: 'status', status: 'running' });

    // If there are more pending requests, emit the next one
    if (session.pendingRequests.length > 0) {
      const next = session.pendingRequests[0];
      if (next.type === 'question' && next.questionRequest) {
        const questions: AgentQuestion[] = next.questionRequest.questions.map(
          (q: NormalizedQuestion) => ({
            question: q.question,
            header: q.header,
            options: q.options.map((o) => ({
              label: o.label,
              description: o.description,
            })),
            multiSelect: q.multiSelect,
          }),
        );
        this.emitEvent(taskId, {
          type: 'question',
          requestId: next.requestId,
          questions,
        });
      } else if (next.type === 'permission' && next.permissionRequest) {
        this.emitEvent(taskId, {
          type: 'permission',
          ...next.permissionRequest,
        });
      }
    }
  }

  async sendMessage(taskId: string, message: string): Promise<void> {
    // If session exists and running, stop it first
    if (this.sessions.has(taskId)) {
      await this.stop(taskId);
    }

    // Create new session (will pick up existing sessionId for resume)
    const session = await this.createSession(taskId);

    try {
      dbg.agentSession('Sending follow-up message for task %s', taskId);
      await this.runBackend(taskId, message, session);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      dbg.agent('Task %s sendMessage failed: %s', taskId, errorMessage);

      // Emit a synthetic error entry so the user sees the error in the timeline
      await this.persistAndEmitSyntheticEntry(taskId, session, {
        id: nanoid(),
        date: new Date().toISOString(),
        isSynthetic: true,
        type: 'result',
        value: errorMessage,
        isError: true,
      });

      await TaskRepository.update(taskId, { status: 'errored' });
      this.emitEvent(taskId, {
        type: 'status',
        status: 'errored',
        error: errorMessage,
      });
    } finally {
      this.sessions.delete(taskId);
    }
  }

  /**
   * Queue a prompt to be sent after the current agent work completes.
   */
  queuePrompt(taskId: string, prompt: string): { promptId: string } {
    const session = this.sessions.get(taskId);
    if (!session) {
      throw new Error(`No active session for task ${taskId}`);
    }

    const queuedPrompt: QueuedPrompt = {
      id: nanoid(),
      content: prompt,
      createdAt: Date.now(),
    };

    session.queuedPrompts.push(queuedPrompt);
    this.emitEvent(taskId, {
      type: 'queue-update',
      queuedPrompts: session.queuedPrompts,
    });

    dbg.agent('Queued prompt %s for task %s', queuedPrompt.id, taskId);
    return { promptId: queuedPrompt.id };
  }

  /**
   * Cancel a specific queued prompt.
   */
  cancelQueuedPrompt(taskId: string, promptId: string): void {
    const session = this.sessions.get(taskId);
    if (!session) {
      throw new Error(`No active session for task ${taskId}`);
    }

    const index = session.queuedPrompts.findIndex((p) => p.id === promptId);
    if (index === -1) {
      throw new Error(`Queued prompt ${promptId} not found`);
    }

    session.queuedPrompts.splice(index, 1);
    this.emitEvent(taskId, {
      type: 'queue-update',
      queuedPrompts: session.queuedPrompts,
    });

    dbg.agent('Cancelled queued prompt %s for task %s', promptId, taskId);
  }

  /**
   * Get current queued prompts for a task.
   */
  getQueuedPrompts(taskId: string): QueuedPrompt[] {
    const session = this.sessions.get(taskId);
    return session?.queuedPrompts ?? [];
  }

  /**
   * Get the current pending request for a task (permission or question).
   * Returns null if no pending request exists.
   */
  getPendingRequest(taskId: string):
    | {
        type: 'permission';
        data: NormalizedPermissionRequest & { taskId: string };
      }
    | {
        type: 'question';
        data: {
          taskId: string;
          requestId: string;
          questions: AgentQuestion[];
        };
      }
    | null {
    const session = this.sessions.get(taskId);
    if (!session || session.pendingRequests.length === 0) {
      return null;
    }

    const request = session.pendingRequests[0];
    if (request.type === 'question' && request.questionRequest) {
      return {
        type: 'question',
        data: {
          taskId,
          requestId: request.requestId,
          questions: request.questionRequest.questions.map(
            (q: NormalizedQuestion) => ({
              question: q.question,
              header: q.header,
              options: q.options.map((o) => ({
                label: o.label,
                description: o.description,
              })),
              multiSelect: q.multiSelect,
            }),
          ),
        },
      };
    }

    if (request.type === 'permission' && request.permissionRequest) {
      return {
        type: 'permission',
        data: {
          taskId,
          ...request.permissionRequest,
        },
      };
    }

    return null;
  }

  async setMode(taskId: string, mode: InteractionMode): Promise<void> {
    dbg.agentSession('Setting mode for task %s to %s', taskId, mode);
    const session = this.sessions.get(taskId);
    if (session?.backendSessionId) {
      await session.backend.setMode(session.backendSessionId, mode);
      dbg.agentSession('Updated backend permission mode for active session');
    }
    await TaskRepository.update(taskId, { interactionMode: mode });
  }

  isRunning(taskId: string): boolean {
    return this.sessions.has(taskId);
  }

  async getMessages(taskId: string): Promise<NormalizedEntry[]> {
    return AgentMessageRepository.findByTaskId(taskId);
  }

  async getMessageCount(taskId: string): Promise<number> {
    return AgentMessageRepository.getMessageCount(taskId);
  }

  async getMessagesWithRawData(taskId: string) {
    const rows = await AgentMessageRepository.findWithRawDataByTaskId(taskId);
    return rows.map((row) => ({
      messageIndex: row.messageIndex,
      rawData: row.rawData ? JSON.parse(row.rawData) : null,
      rawFormat: row.rawFormat,
      backendSessionId: row.backendSessionId,
      normalizedData: row.normalizedData
        ? JSON.parse(row.normalizedData)
        : null,
      createdAt: row.createdAt,
    }));
  }

  /**
   * Re-process normalization for all raw messages of a task.
   * Deletes existing normalized messages and re-creates them from raw data.
   * Returns the count of newly created normalized messages.
   */
  async reprocessNormalization(taskId: string): Promise<number> {
    return AgentMessageRepository.reprocessNormalization(taskId);
  }

  /**
   * Recover tasks that were left in 'running' or 'waiting' state from a previous app session.
   * These tasks were interrupted by app shutdown/crash and should be marked as 'interrupted'.
   * Should be called on app startup before the main window is shown.
   */
  async recoverStaleTasks(): Promise<void> {
    const staleTasks = await TaskRepository.findByStatuses([
      'running',
      'waiting',
    ]);

    for (const task of staleTasks) {
      await TaskRepository.update(task.id, { status: 'interrupted' });
      // Note: No need to emit status here since no UI is connected yet at startup
    }

    if (staleTasks.length > 0) {
      dbg.agent('Recovered %d stale task(s) on startup', staleTasks.length);
    }
  }
}

export const agentService = new AgentService();
